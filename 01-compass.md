**Compass**

I've found I have two primary ways of processing technical information that works for me. So that I can learn the technical skills that help me stay relevant and employed: write code to solve problms (and ideally keep using that language so that the newly acquired information doesn't become crowded out by other things) and write out things by hand. There is something about the analogue process of writing by hand which helps the information to stick. Abd tge distance between thought and written word seems shorter. One challenge I have with this approach is maintaining legible text; my word formation has become less rigorous over decades of keyboard use and sometimes I revert to not writing joined up if I'm lapsing into doctor's scrawl.

So for this book I thought I would experiment with hand-writing first to see how the result is different.

![image|375x500](upload://y29NsshW8VsQmgWae4HdSkk7YkE.jpeg)


It's slow. And for learning technical material painfully slow. I remember when I was learning Java from Bruce Eckel's book (back in 1997) that I write out key concepts by hand in order to remember them. Over the years and through my daughter's experience I suspect I have developed coping mechanisms for ADHD. (In my first degree ... Computer Science and Electronic Engineering I struggled to stay engaged as the course went on, so I didn't get the degree I was capable of. Sixteen years later, and Â£30K poorer, I took a a masters in information security and came out with a distinction.) 

I suspect there are other coders who experience some form of related challenge. And I think I can help those people. And there could be many of them; we're told everyone could benefit from being able to code. I also think about being a parent, losing my Dad when I was four. My Mum probably feeling overwhelmed most of the time. Being told aged 18 that it was time to leave. And developing coping mechanisms, and sheer bloody-minded persistence. No safety net.

I currently see two books. On the one hand I'm embracing the curiosity of the ADHD brain that jumps around and makes connections. There is a talent (or is it a skill) I have for identify similar song segments, or less well-known actors and what other thing they've acted in. I'm quite good at Name That Tune, particularly with 80's Pop, much to the consternation of my colleagues when that was our Zoom social activity. But I couldn't think of a way to monetize it. (I guess Shazam did.) I thought about doing something based on MP3 files in Dropbox and then building a playlist based on key and beat. But I don't think it's as useful a business as education. Education is the way people can better themselves and acquire resources for a better life. And making connections, between non-obvious related things, while learning technology could provide an interesting slant.

So, two books: 

1. teaching my children (and others) to code
2. Rust for centralised and de-centralised applications

The first one ... from Dad to my children. Teaching them how to code. At least one wants to. Maybe the others will read it too out of sheer curiosity to see if it's any good. My eldest daughter, who introduced me to ADHD has an internship coming up. So I'm writing it for her, and I hope my other children will read it too. I have a vague notion about abstractions ... layers (which ogres like Shrek have). 

My first coding language was C, which is _close to the metal_. You need to manage your own memory, and you build programmes that compile to native code which the machine can run directly. Then it was clear that managing your own memory is a real pain, and source of bugs. So garbage collection became more prevalent: you let the interpreter allocate and clean up the memory for you. And now we're again looking for performant languages like Rust which use less electricity so it's good for the planet. 

Is it helpful to introduce a beginner to abstractions? Electrons/transisters/binary/state/data types. I think so. I might borrow some of the ideas from SICP. (Hurray for Creative Commons.) Because we're dealing with ones and zeroes, but we want to represent decimal numbers, which can introduce some interesting issues. Or how do we represent non-Latin character sets. And what about sending text over a wire to another computer? Or large numbers ... what is the language requires you to say "how big" your numbers are, versus figuring it out for you. And data types that have a native representation are much faster than "big" integers for example. 

The other book is the Rust / blockchain book. What a bumpy ride it's been this week with the collapse of Luna, which had a market capitalisation of $50Bn. (Lehman Brothers was $60Bn.) Rust is a modern successor to C, And it will be popular in performance-critical applications: Web augmented reality. Cloud applications that are billed based on memory and CPU usage. But it's non-trivial.

Actually there's a third book I've been thinking about. How to migrate from the stack I currently use in my day job to a stack that validates my ability to keep earning good money. The contract market has taken a battering after the IR35 rules were changed last year. I think I can hang in there long enough to get my crypto credentials bolstered sufficiently. I don't think Bitcoin or Ethereum are going away.

And maybe the coding programme for the easily distracted will take off.

![image|375x500](upload://hJdrrQnybrneGLpfPAuvVCm66W3.jpeg)



P.S. There's another project I've been thinking of. My Dad built me a plywood box on which he mounted an assortment of (slider, toggle and rocker) switches and lamps. In the four years we overlapped it's one of the visceral things I remember. I want to explore something similar with my children, or others. Like a combination of hardware and software. 

For the Rust book, I've registered _rustychain.xyz_. I'm musing on the other title.

@Beaver
